## 0. 기본 원칙 (General Principles)
<details>
<summary>펼쳐보기</summary>

- **Semantic Consistency**: **동일한 설정(Config)은 어떤 언어/플랫폼에서 실행되든 동일한 의미(Semantics)와 동일한 HTTP 요청 결과를 보장해야 합니다.**
    - 이를 위해, 플랫폼에 따라 동작이 달라지거나 구현이 불가능한 기능은 **`platform`** 객체 아래로 분리하여 명시적으로 사용하도록 합니다.
- **Stateless**: `jady.call`은 상태를 가지지 않는 순수 함수(Pure Function) 혹은 정적 메서드(Static Method)처럼 동작해야 합니다.
    - **No Cookie Jar**: 라이브러리는 내부적으로 쿠키 저장소(Cookie Jar)를 유지하지 않습니다. 즉, 이전 요청의 `Set-Cookie`가 다음 요청에 자동으로 포함되지 않습니다.
        - **Browser Exception**: 단, 브라우저 환경에서는 브라우저(User Agent)가 자체적으로 관리하는 쿠키 저장소가 동작하며, 이는 라이브러리가 제어할 수 없는 영역입니다.
    - **Connection Pooling**: 단, 성능 최적화를 위해 내부적으로 TCP/TLS 연결 풀(Connection Pool)은 전역적으로 관리되거나 재사용될 수 있습니다. 이는 사용자 레벨의 세션 상태(Session State)와는 구별됩니다.
- **Immutability**: 라이브러리는 사용자가 전달한 `config` 객체를 **변경하지 않아야 합니다(Immutable)**. 내부 처리를 위해 필요한 경우 복사본을 사용하여, 원본 객체의 재사용성을 보장해야 합니다.
- **Thread Safety**: `jady.call` 함수는 **스레드 안전(Thread-safe)**해야 합니다. 멀티스레드 환경에서 동시에 호출되더라도 내부 상태 공유로 인한 부작용이 없어야 합니다.
- **Fail Fast**: 잘못된 설정(Invalid Config)이나 호환되지 않는 옵션 조합이 감지되면, 요청을 보내기 전에 즉시 **예외(Exception)**를 발생시켜야 합니다. (Silent Failure 방지)
- **Predictable Behavior**: 동일한 `config` 객체는 항상 동일한 HTTP 요청(메서드, URL, 헤더, 본문)을 생성해야 합니다. 응답 객체에 포함되는 `duration`이나 자동 생성된 `requestId` 등 동적인 값은 예외입니다. 이는 테스트 용이성과 예측 가능성을 보장합니다.
- **Consistent Error Structure**: 라이브러리에서 발생하는 모든 예외는 **3. 에러 처리** 섹션에 정의된 표준 구조(코드, 메시지 등)를 따라야 합니다. 이를 통해 사용자는 언어에 상관없이 일관된 방식으로 에러를 처리할 수 있습니다.
- **Minimal Dependency**: 라이브러리는 외부 의존성을 최소화하여 가볍고 이식성이 높아야 합니다. 플랫폼 내장 기능(Native API)을 최대한 활용하는 것을 권장합니다.
- **Explicit Over Implicit**: 암시적인 "마법" 동작보다는 명시적인 설정을 우선합니다. 사용자가 설정하지 않은 값에 대해 라이브러리가 임의로 추측하여 동작을 변경하지 않아야 하며, 모든 기본값(Default)은 문서에 명시된 대로만 적용되어야 합니다.
- **RFC Compliance**: 동작이 모호하거나 문서에 정의되지 않은 엣지 케이스의 경우, 최신 HTTP RFC 표준(RFC 723x, RFC 911x 등)을 따르는 것을 원칙으로 합니다.
- **Secure by Default**: 편의성보다 보안을 우선합니다. 모든 보안 관련 설정(SSL 검증, 살균 등)의 기본값은 가장 안전한 상태여야 합니다.
- **Security by Design**: 보안은 라이브러리 설계 및 구현의 모든 단계에서 핵심 고려 사항이어야 합니다. 데이터 처리, 옵션 설계, 에러 보고 방식 등 모든 측면에서 보안을 최우선으로 고려해야 합니다.
- **UTF-8 by Default**: 문자열 처리(URL, JSON, Body, Auth 등)의 기본 인코딩은 **UTF-8**입니다. 단, HTTP 헤더와 같이 표준 스펙이 특정 인코딩(ASCII/ISO-8859-1)을 강제하는 경우는 예외입니다.
- **Caller Ownership**: 리소스(Stream, File Handle 등)의 수명 주기는 **호출자(Caller)**가 관리합니다.
- **Input**: 사용자가 전달한 스트림이나 파일 핸들은 라이브러리가 읽기만 할 뿐, 전송 후 자동으로 닫지 않습니다.
- **Idempotency**: `jady.call`은 재시도 메커니즘을 제공하지만, 요청의 **멱등성(Idempotency)**은 보장하지 않습니다. 쓰기 작업(Write)의 경우, 서버 측에서 중복 실행에 대한 방지 로직을 구현하거나, 사용자가 직접 제어해야 합니다.
- **Callback Security**: `hooks`와 같은 콜백 함수를 통해 요청 설정을 변경할 때 보안에 유의해야 합니다. 콜백 내부에서 민감한 헤더를 수정하거나, 로컬 파일 시스템에 접근하는 등의 작업은 보안 위험을 초래할 수 있습니다.
- **Output**: `responseType: 'stream'` 등으로 반환된 리소스는 사용자가 명시적으로 닫아야(Close) 합니다.
- **Type Safety**: 정적 타입 언어(TypeScript, Java, Go 등) 구현체는 컴파일 타임에 오류를 잡을 수 있도록 정확한 타입 정의와 제네릭(Generics)을 제공해야 합니다.
- **Atomic Operation**: 모든 요청은 성공 또는 실패의 원자적(Atomic) 결과를 가져야 합니다. 부분적인 성공이나 어중간한 상태(Partial State)로 남지 않아야 하며, 실패 시에는 명확한 예외를 발생시켜야 합니다.
- **Date Formats**: Date 객체는 서버와 호환성을 위해 ISO 8601 문자열로 직렬화해야 합니다.
- **Cleanup on Failure**: 요청이 실패하거나 취소(Abort)된 경우, 라이브러리는 내부적으로 생성한 모든 리소스(소켓, 타이머, 메모리 버퍼 등)를 즉시 해제(Cleanup)해야 합니다.
- **No Global Side Effect**: 라이브러리의 동작은 전역 환경(Global Scope, Process Environment 등)을 변경하거나 오염시키지 않아야 합니다.
- **Traceability**: 요청의 전체 수명 주기(Life-cycle) 동안 식별자(`requestId`)와 메타데이터(`meta`)는 보존되어야 하며, 로그나 에러 객체를 통해 추적 가능해야 합니다.
- **Deterministic Execution**: 비동기 로직(Hooks, Retry, Redirect 등)의 실행 순서는 네트워크 상태나 시스템 부하에 관계없이 항상 결정론적(Deterministic)이어야 합니다. (Race Condition 방지)

- **Developer Experience First**: API는 직관적이어야 하며, 에러 메시지는 명확하고 디버깅에 유용해야 합니다. 잘 정리된 문서는 라이브러리의 핵심적인 부분으로 간주됩니다.
-   **Observability**: 로깅, 메트릭, 트레이싱을 통해 라이브러리의 내부 동작을 관찰할 수 있도록 지원하는 것을 고려해볼 수 있습니다.

- **Clear Versioning Policy**: 모든 릴리즈는 유의적 버전(Semantic Versioning) 2.0.0 규칙을 엄격히 준수합니다. 이를 통해 사용자는 버전 업그레이드에 따른 호환성 변경을 명확히 예측할 수 있습니다. 주요 변경(Breaking Change)은 반드시 메이저 버전 업데이트를 통해 이루어지며, 상세한 마이그레이션 가이드를 함께 제공합니다.
- **Performance as a Feature**: 라이브러리는 최소한의 오버헤드와 효율적인 리소스 사용을 목표로 합니다. 불필요한 메모리 할당이나 연산을 지양하고, 대용량 데이터 처리 시에도 안정적인 성능을 제공해야 합니다.
- **Extensibility & Testability**: 라이브러리의 핵심 기능은 `hooks`나 `adapter`와 같은 명확한 인터페이스를 통해 확장 가능해야 합니다. 또한, 모든 동작은 예측 가능해야 하며, 사용자가 자신의 코드를 쉽게 테스트할 수 있도록 Mocking과 같은 테스트 전략을 지원하는 구조를 지향합니다.

</details>



## 0.1. 비동기 (Asynchronous)
모든 구현체는 기본적으로 **비동기(Async)** 동작을 지향해야 합니다. (Return Promise, Future, Coroutine, etc.)